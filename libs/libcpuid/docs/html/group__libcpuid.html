<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcpuid: LibCPUID</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcpuid
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LibCPUID</div>  </div>
</div><!--header-->
<div class="contents">

<p>LibCPUID provides CPU identification.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains just the raw CPUID data.  <a href="structcpu__raw__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__sgx__t.html">cpu_sgx_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This contains information about SGX features of the processor Example usage:  <a href="structcpu__sgx__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__id__t.html">cpu_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This contains the recognized CPU features/info.  <a href="structcpu__id__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__mark__t.html">cpu_mark_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.  <a href="structcpu__mark__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__epc__t.html">cpu_epc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value of <a class="el" href="group__libcpuid.html#gad973835515aa3b0d807b07279f03b965" title="Fetches information about an EPC (Enclave Page Cache) area.">cpuid_get_epc()</a>.  <a href="structcpu__epc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpu__list__t.html">cpu_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure that holds a list of processor names  <a href="structcpu__list__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad4a022c32a50d38207631862560a1aab"><td class="memItemLeft" align="right" valign="top"><a id="gad4a022c32a50d38207631862560a1aab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_CPU_VENDORS</b>&#160;&#160;&#160;NUM_CPU_VENDORS</td></tr>
<tr class="separator:gad4a022c32a50d38207631862560a1aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bede587b8d4922704f2cad3e629754"><td class="memItemLeft" align="right" valign="top"><a id="gae6bede587b8d4922704f2cad3e629754"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPU_INVALID_VALUE</b>&#160;&#160;&#160;0x3fffffff</td></tr>
<tr class="separator:gae6bede587b8d4922704f2cad3e629754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad15ed59794d43f419af14f78f130d3d4"><td class="memItemLeft" align="right" valign="top"><a id="gad15ed59794d43f419af14f78f130d3d4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>libcpuid_warn_fn_t</b>) (const char *msg)</td></tr>
<tr class="separator:gad15ed59794d43f419af14f78f130d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaee3591049f485bb93dbd26dd91684d28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a> { <br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a0ff85c91faaad5edc40b8b13bf5872a9">VENDOR_INTEL</a> = 0, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a98f56d8179428f9ae8a673281e490fb7">VENDOR_AMD</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28ad78b1b4a1b336bba96d40cb511ca0739">VENDOR_CYRIX</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a0bbc1eea1798b997ef8a48c61eb87127">VENDOR_NEXGEN</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28ae0f24610ed6f971e45376b01249400f2">VENDOR_TRANSMETA</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a71ab6d3938d2ea3f53faf7583fb75314">VENDOR_UMC</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28aca19c521336c04c427d4bd4efcf20c88">VENDOR_CENTAUR</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a38cda576d1ef80f226b84c2c726fcaf4">VENDOR_RISE</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a47ddfbe49b7c864e04acd13af0b384fb">VENDOR_SIS</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28aaaee595f5e3f1e06a5fa7a418aafe9c0">VENDOR_NSC</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28acdf07de1723fc7e21a80f5d4053ef150">VENDOR_HYGON</a>, 
<a class="el" href="group__libcpuid.html#ggaee3591049f485bb93dbd26dd91684d28a44775e86f4d8a7e1ca5f62175ff6f486">NUM_CPU_VENDORS</a>, 
<br />
&#160;&#160;<b>VENDOR_UNKNOWN</b> = -1
<br />
 }</td></tr>
<tr class="memdesc:gaee3591049f485bb93dbd26dd91684d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU vendor, as guessed from the Vendor String.  <a href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">More...</a><br /></td></tr>
<tr class="separator:gaee3591049f485bb93dbd26dd91684d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b398deee739a645387c7329a4c289"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga4c0b398deee739a645387c7329a4c289">cpu_feature_t</a> { <br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a453849150533658bb299b8a6dceb4363">CPU_FEATURE_FPU</a> = 0, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a25f411f7e138c5d268e70045c6158329">CPU_FEATURE_VME</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ab562af0f4bc281ff2ee36b122ff88058">CPU_FEATURE_DE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a55fdf1520915f360865af0e33769845e">CPU_FEATURE_PSE</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a48ff7bd2f3e866b0cc33591a49f52e73">CPU_FEATURE_TSC</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a1865c515f1dfe0e7d6a57827fc83cbd9">CPU_FEATURE_MSR</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289acc96bbaefe5f0d4d11dbe191dc8926f4">CPU_FEATURE_PAE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a17ec983ccfddedbc7a9b00d20a665685">CPU_FEATURE_MCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8f942324f3c7e6b2977a0799736b8874">CPU_FEATURE_CX8</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a1acd5ed0fd11f8181ee5355620d1df31">CPU_FEATURE_APIC</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa385b21280ba8b58e96e4cf93b21f21e">CPU_FEATURE_MTRR</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a3390256a622bd4baf24e023b99515fde">CPU_FEATURE_SEP</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ac0244dd1443fcf61782e534a964b2cb8">CPU_FEATURE_PGE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ac869b2e0261d320839fc87bebddf2734">CPU_FEATURE_MCA</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa52edbfedff12ef2634779677d2616de">CPU_FEATURE_CMOV</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a90640b8f73923c881388e796b46d0f61">CPU_FEATURE_PAT</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a5ac632d942e4e05daea1277e4a9501d4">CPU_FEATURE_PSE36</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289adf54ae06b9144822b18aad09b56aa24f">CPU_FEATURE_PN</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a3a9f860c11b538507396b52d9b87103a">CPU_FEATURE_CLFLUSH</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289af2c956245b6c27448453374f5f3835de">CPU_FEATURE_DTS</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a3cca7d5d4dbba92daf3458e925363004">CPU_FEATURE_ACPI</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a85890ccf3243ad847a94c4af7d74f5bb">CPU_FEATURE_MMX</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ae9a107e859c13e63568f820bcd9c85ad">CPU_FEATURE_FXSR</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa68e99c4dc5a309e093e9dfa72bb39ca">CPU_FEATURE_SSE</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4256f8c13070e3b8bd6be3010a5c1226">CPU_FEATURE_SSE2</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289abb1a066840045516b62bcaa0abf8f654">CPU_FEATURE_SS</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a67dfcf32f2458471da57a087220566ac">CPU_FEATURE_HT</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a41a6517364e91773f80379a00a4cc926">CPU_FEATURE_TM</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ae035f6e3adc1cb92a313792cdd074e72">CPU_FEATURE_IA64</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aeb144ddd3365cba1798b3c32a09089a9">CPU_FEATURE_PBE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a2000e3d103c50e66ae00f59d8adcc355">CPU_FEATURE_PNI</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4fbe032106b78197602cc65e38499524">CPU_FEATURE_PCLMUL</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ad37850e3455312b32bdfa815cdd860b7">CPU_FEATURE_DTS64</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a1b9e596067a149fd5d4e8f5ccf5ed5d1">CPU_FEATURE_MONITOR</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ab84f0cfd4a8e324f180017c3e390f82d">CPU_FEATURE_DS_CPL</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a3575a558eccc8193a1d8fe8f74a30152">CPU_FEATURE_VMX</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a89f81845a90b08193b19352f75787cf9">CPU_FEATURE_SMX</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a7a4eb4645b87f3e1f71a757652278afd">CPU_FEATURE_EST</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a96f6a665327dda077698d896a52f9ec0">CPU_FEATURE_TM2</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a7d6981f45c7c0782c35ed3a2e7a1360c">CPU_FEATURE_SSSE3</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a55ca5e131471a2da71b80f0cd4606063">CPU_FEATURE_CID</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a46b3cc99edc475b1af401ce11bb74f72">CPU_FEATURE_CX16</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ae4a1cf449ea63c0fd241eb71de6241d8">CPU_FEATURE_XTPR</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a98bfdf89c13198320684165a90bdf823">CPU_FEATURE_PDCM</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8e37ce7e2ac8218888431702e6206f85">CPU_FEATURE_DCA</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8608d346e0c702d740d03ce42c87f186">CPU_FEATURE_SSE4_1</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a24c4a542403f6a3399d58ecf7bbe2493">CPU_FEATURE_SSE4_2</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a6415775054c1b1225d286ebf6b2b873b">CPU_FEATURE_SYSCALL</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ad0aadd272ee5f176561d19b630ccd0ab">CPU_FEATURE_XD</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289acafda352a331b5091996f50ca62ec404">CPU_FEATURE_MOVBE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8a950b6d548ea934f26e1f8118d284f6">CPU_FEATURE_POPCNT</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ae612eb3cc570f400c2542c0de6b6079d">CPU_FEATURE_AES</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a490e07c3f0e90180e2fe3d833f7fc00a">CPU_FEATURE_XSAVE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a52f44e2b623c249be3bdeee523221e92">CPU_FEATURE_OSXSAVE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289acfd03e7e97fa2fcf234cf88dd250eaa5">CPU_FEATURE_AVX</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ace6439b05c8e49701e281fab54adef47">CPU_FEATURE_MMXEXT</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ad196550729f133d1a5a5ad2372a1d36f">CPU_FEATURE_3DNOW</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a63bad125f7d98decb95f8f7caa6ab382">CPU_FEATURE_3DNOWEXT</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4bd0778d9173fedb1901455d04d5d625">CPU_FEATURE_NX</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ac8cf5bd2c03e7cbebd5c9b92ca048809">CPU_FEATURE_FXSR_OPT</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a9bc3a4d9d238ae8a0827b206ad8914d9">CPU_FEATURE_RDTSCP</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289acc02143e1c19a07321131d2435f98cae">CPU_FEATURE_LM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8d6f0cef0aaa5ae341bd9a57e5c2f453">CPU_FEATURE_LAHF_LM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a518d74659dc7c7f6c6286e8b7af5b2f4">CPU_FEATURE_CMP_LEGACY</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4f10a68bc2590a75ec9cd1079c137f97">CPU_FEATURE_SVM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a65f25f348ca56a8acf114125021cc61f">CPU_FEATURE_ABM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289af7d43dab2ccad4c9aaae131adb16d24d">CPU_FEATURE_MISALIGNSSE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa452c85116a8be446cd76e14a15d5398">CPU_FEATURE_SSE4A</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa713ac40f60eb9879f3d67d0c76f67b6">CPU_FEATURE_3DNOWPREFETCH</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a622ddfde42bdf056fb833f3ea1db6a49">CPU_FEATURE_OSVW</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ac5366b66425729071fe5e2a2728de632">CPU_FEATURE_IBS</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a179c10fda2621f4cfc6426d988da0876">CPU_FEATURE_SSE5</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a21cb4bb1b77f8a24873c6b7974efc704">CPU_FEATURE_SKINIT</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aa1758a8841c2267e8581e5228491ca3d">CPU_FEATURE_WDT</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a664c7e2732b847819c1a000717da652e">CPU_FEATURE_TS</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a2242333b009477a54a5807e9b972086a">CPU_FEATURE_FID</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a92fc0b056726842599cc54bd90b1a0be">CPU_FEATURE_VID</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a27c791308415baaba9f751238b9f86ea">CPU_FEATURE_TTP</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ab79d96191ba266776b55b54818b66cd5">CPU_FEATURE_TM_AMD</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a26051b02eb1bd376da9e889bb9b8b154">CPU_FEATURE_STC</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a470838a8e63aca9a48b3f3c33030cc54">CPU_FEATURE_100MHZSTEPS</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a2cb12da6a5c22a8cf496137c2a1c368b">CPU_FEATURE_HWPSTATE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a839020f8c8739dc5d753581205a94597">CPU_FEATURE_CONSTANT_TSC</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a567aa09c705213218b85b78c8f6441a9">CPU_FEATURE_XOP</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289abfcf54efabb2bfef6912b82b5b40f69d">CPU_FEATURE_FMA3</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a43059146e6421866ef8011958f7f2572">CPU_FEATURE_FMA4</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289adf4ac8554a8467a61970083a54166340">CPU_FEATURE_TBM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289afeda100f9de3f9e880c75593d3ac948c">CPU_FEATURE_F16C</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a1e7557ccde6b429df4532384a1fa9f82">CPU_FEATURE_RDRAND</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a6b31b846f054bbec14f8569a6086b00b">CPU_FEATURE_X2APIC</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289afa0842a9b99f9f77920239127c922d1c">CPU_FEATURE_CPB</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8366a2ebea8cce37a8f9d921425ea09b">CPU_FEATURE_APERFMPERF</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289adfd99dbe1be50fa605c08b82fc85b8b8">CPU_FEATURE_PFI</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aaeafcab708552f1e8aef36735e880c51">CPU_FEATURE_PA</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a18394e14e517073195b57ec9aee5ea15">CPU_FEATURE_AVX2</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aea28e9015a5fa858eb34732881705450">CPU_FEATURE_BMI1</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ab83da08aec73311f80d303beadd14682">CPU_FEATURE_BMI2</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a9f78f8ffbcc16a647381a4a48929e300">CPU_FEATURE_HLE</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a2772648837f617553ba3e441b760a341">CPU_FEATURE_RTM</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a87a7473d47e00e1cf07a424728ad1b67">CPU_FEATURE_AVX512F</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a8814d6aa3b83f4c857f857a73952c4a4">CPU_FEATURE_AVX512DQ</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a36ef43b0a41b9866757a3b3984197fbe">CPU_FEATURE_AVX512PF</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a5fc80b7adcd252d915a9c4fc850b8268">CPU_FEATURE_AVX512ER</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289ae901d15aac437570fc9f7cbddfdbafa2">CPU_FEATURE_AVX512CD</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a650d153fab53759e4ea1a187effa9c8a">CPU_FEATURE_SHA_NI</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a3463b7c5837d2034380ef8b0c8ba9a8c">CPU_FEATURE_AVX512BW</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289add282121c269c2763a1f7b1d3358b7cf">CPU_FEATURE_AVX512VL</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a26c943581012c705d53af5800af60d16">CPU_FEATURE_SGX</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a9bf2318b5d28e37ad55b055692508c58">CPU_FEATURE_RDSEED</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a78800c3a6afc1cc3bcc5cf7b337e5e9a">CPU_FEATURE_ADX</a>, 
<a class="el" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289aeb7e119b120a657920fc1e5214e36b0c">CPU_FEATURE_AVX512VNNI</a>, 
<b>NUM_CPU_FEATURES</b>
<br />
 }</td></tr>
<tr class="memdesc:ga4c0b398deee739a645387c7329a4c289"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU feature identifiers.  <a href="group__libcpuid.html#ga4c0b398deee739a645387c7329a4c289">More...</a><br /></td></tr>
<tr class="separator:ga4c0b398deee739a645387c7329a4c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada395ff8a06f8f37d09a4a07926aa661"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gada395ff8a06f8f37d09a4a07926aa661">cpu_hint_t</a> { <a class="el" href="group__libcpuid.html#ggada395ff8a06f8f37d09a4a07926aa661a590d513544b1eb01e67751085f22e1eb">CPU_HINT_SSE_SIZE_AUTH</a> = 0, 
<b>NUM_CPU_HINTS</b>
 }</td></tr>
<tr class="memdesc:gada395ff8a06f8f37d09a4a07926aa661"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU detection hints identifiers.  <a href="group__libcpuid.html#gada395ff8a06f8f37d09a4a07926aa661">More...</a><br /></td></tr>
<tr class="separator:gada395ff8a06f8f37d09a4a07926aa661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7731d6f7447310c9a29d2c92c867d4f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gab7731d6f7447310c9a29d2c92c867d4f">cpu_sgx_feature_t</a> { <a class="el" href="group__libcpuid.html#ggab7731d6f7447310c9a29d2c92c867d4fa09de49d5e0772b8ee6e232f9aeefcf25">INTEL_SGX1</a>, 
<a class="el" href="group__libcpuid.html#ggab7731d6f7447310c9a29d2c92c867d4fa2943256b42664d19b46a7f086dab3488">INTEL_SGX2</a>, 
<b>NUM_SGX_FEATURES</b>
 }</td></tr>
<tr class="memdesc:gab7731d6f7447310c9a29d2c92c867d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGX features flags.  <a href="group__libcpuid.html#gab7731d6f7447310c9a29d2c92c867d4f">More...</a><br /></td></tr>
<tr class="separator:gab7731d6f7447310c9a29d2c92c867d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaad3aee57ed8705424f5884fb15849f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f">cpu_error_t</a> { <br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849faa26c163b80b1f6786ca81dadc14b00fb">ERR_OK</a> = 0, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa606d51bab169e05a118d986f34e2ac24">ERR_NO_CPUID</a> = -1, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa97b10b1d6816df08f3d6ac947c7177e0">ERR_NO_RDTSC</a> = -2, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa1859972576f52b73a9661d101a6328a1">ERR_NO_MEM</a> = -3, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa7235954be32cd0166432c3f7a5d61bb5">ERR_OPEN</a> = -4, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa0dd33d6ae54908e2f361f9f0bc7cf64f">ERR_BADFMT</a> = -5, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa6ba069bd5e69d2abb4b0afd1ee2637e8">ERR_NOT_IMP</a> = -6, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa231b5ba999016056b60e42d7e50efb2e">ERR_CPU_UNKN</a> = -7, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa379883983dfe8ed4433d1ea5abf37d1d">ERR_NO_RDMSR</a> = -8, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa87e406a43767ad4c28a746e6bc3a1112">ERR_NO_DRIVER</a> = -9, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa1a2c6d04958fb4436318f6460e1b5f1b">ERR_NO_PERMS</a> = -10, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849faad3e8c13adfc55ea1cd105e92972dd33">ERR_EXTRACT</a> = -11, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fad84654b76a5ac772f3463e055702a360">ERR_HANDLE</a> = -12, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa666f5844a2eeffd7f4e3333e4bfd0d6a">ERR_INVMSR</a> = -13, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fad0b3acac21097e986877db7c9f9f631b">ERR_INVCNB</a> = -14, 
<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fac00bab796cfece6df01a01538b7f5b17">ERR_HANDLE_R</a> = -15, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#ggaaaad3aee57ed8705424f5884fb15849fa717b2cb8ca3bcc737f8c76ee657558ae">ERR_INVRANGE</a> = -16
<br />
 }</td></tr>
<tr class="memdesc:gaaaad3aee57ed8705424f5884fb15849f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes common library error codes.  <a href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f">More...</a><br /></td></tr>
<tr class="separator:gaaaad3aee57ed8705424f5884fb15849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e38033529430a12f20089b382d603a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga0e38033529430a12f20089b382d603a6">cpu_msrinfo_request_t</a> { <br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6a6341e3edd069ee19e9f74bdc0d6207fe">INFO_MPERF</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6ad366b181e477c5003915ddd6dd97a46b">INFO_APERF</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6a252a37590925f8b5b01fbd29984b2b2a">INFO_MIN_MULTIPLIER</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6aa5299acc66aaa3426e921658d2a318d9">INFO_CUR_MULTIPLIER</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6aef85eba90772abc57cb874aeacfb0f9d">INFO_MAX_MULTIPLIER</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6ae8f05f1a8766aa8fec25051e5fffefe2">INFO_TEMPERATURE</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6a6f67768463665d06172cebe58c9b02af">INFO_THROTTLING</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6a8b113e4509ae0df8110230fca5ec8266">INFO_VOLTAGE</a>, 
<br />
&#160;&#160;<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6a1128829d5c5e8b2cab03e0ab93127f8b">INFO_BCLK</a>, 
<a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6ae8599601c81d3fdc60c353fc95775f14">INFO_BUS_CLOCK</a>
<br />
 }</td></tr>
<tr class="separator:ga0e38033529430a12f20089b382d603a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1951ec0d29f43037df5e2e14cbae44b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga1951ec0d29f43037df5e2e14cbae44b3">cpuid_get_total_cpus</a> (void)</td></tr>
<tr class="memdesc:ga1951ec0d29f43037df5e2e14cbae44b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of logical CPU threads (even if CPUID is not present).  <a href="group__libcpuid.html#ga1951ec0d29f43037df5e2e14cbae44b3">More...</a><br /></td></tr>
<tr class="separator:ga1951ec0d29f43037df5e2e14cbae44b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b686ad8bf6d231de8d8383090022b4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga2b686ad8bf6d231de8d8383090022b4f">cpuid_present</a> (void)</td></tr>
<tr class="memdesc:ga2b686ad8bf6d231de8d8383090022b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the CPUID instruction is supported.  <a href="group__libcpuid.html#ga2b686ad8bf6d231de8d8383090022b4f">More...</a><br /></td></tr>
<tr class="separator:ga2b686ad8bf6d231de8d8383090022b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b66c6c5b7cb18218fd39fee60a72d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga43b66c6c5b7cb18218fd39fee60a72d2">cpu_exec_cpuid</a> (uint32_t eax, uint32_t *regs)</td></tr>
<tr class="memdesc:ga43b66c6c5b7cb18218fd39fee60a72d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CPUID instruction.  <a href="group__libcpuid.html#ga43b66c6c5b7cb18218fd39fee60a72d2">More...</a><br /></td></tr>
<tr class="separator:ga43b66c6c5b7cb18218fd39fee60a72d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca716b437d82b2cfc97bc9f5cd1254a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga8ca716b437d82b2cfc97bc9f5cd1254a">cpu_exec_cpuid_ext</a> (uint32_t *regs)</td></tr>
<tr class="memdesc:ga8ca716b437d82b2cfc97bc9f5cd1254a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CPUID instruction with the given input registers.  <a href="group__libcpuid.html#ga8ca716b437d82b2cfc97bc9f5cd1254a">More...</a><br /></td></tr>
<tr class="separator:ga8ca716b437d82b2cfc97bc9f5cd1254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc107ea367e6b918ca17fdf2c492746"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746">cpuid_get_raw_data</a> (struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *data)</td></tr>
<tr class="memdesc:gacfc107ea367e6b918ca17fdf2c492746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the raw CPUID data from the current CPU.  <a href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746">More...</a><br /></td></tr>
<tr class="separator:gacfc107ea367e6b918ca17fdf2c492746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454db9d6dcf13250280cf9b64314235e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga454db9d6dcf13250280cf9b64314235e">cpuid_serialize_raw_data</a> (struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *data, const char *filename)</td></tr>
<tr class="memdesc:ga454db9d6dcf13250280cf9b64314235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the raw CPUID data to a text file.  <a href="group__libcpuid.html#ga454db9d6dcf13250280cf9b64314235e">More...</a><br /></td></tr>
<tr class="separator:ga454db9d6dcf13250280cf9b64314235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c337c82f669c5c158f25716c080f6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gad6c337c82f669c5c158f25716c080f6c">cpuid_deserialize_raw_data</a> (struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *data, const char *filename)</td></tr>
<tr class="memdesc:gad6c337c82f669c5c158f25716c080f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads raw CPUID data from file.  <a href="group__libcpuid.html#gad6c337c82f669c5c158f25716c080f6c">More...</a><br /></td></tr>
<tr class="separator:gad6c337c82f669c5c158f25716c080f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b5bcc626ff3dd0482553657f9d600e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e">cpu_identify</a> (struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *raw, struct <a class="el" href="structcpu__id__t.html">cpu_id_t</a> *data)</td></tr>
<tr class="memdesc:gaa0b5bcc626ff3dd0482553657f9d600e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the CPU.  <a href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e">More...</a><br /></td></tr>
<tr class="separator:gaa0b5bcc626ff3dd0482553657f9d600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e55a2581749333e4cfe3aad291e3889"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga1e55a2581749333e4cfe3aad291e3889">cpu_feature_str</a> (<a class="el" href="group__libcpuid.html#ga4c0b398deee739a645387c7329a4c289">cpu_feature_t</a> feature)</td></tr>
<tr class="memdesc:ga1e55a2581749333e4cfe3aad291e3889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the short textual representation of a CPU flag.  <a href="group__libcpuid.html#ga1e55a2581749333e4cfe3aad291e3889">More...</a><br /></td></tr>
<tr class="separator:ga1e55a2581749333e4cfe3aad291e3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e877c240b70b78f0781aad37f4c169"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a> (void)</td></tr>
<tr class="memdesc:gaa9e877c240b70b78f0781aad37f4c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns textual description of the last error.  <a href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">More...</a><br /></td></tr>
<tr class="separator:gaa9e877c240b70b78f0781aad37f4c169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fe7335dd44017d8a653b6e2dc8977e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga08fe7335dd44017d8a653b6e2dc8977e">cpu_rdtsc</a> (uint64_t *result)</td></tr>
<tr class="memdesc:ga08fe7335dd44017d8a653b6e2dc8977e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes RDTSC.  <a href="group__libcpuid.html#ga08fe7335dd44017d8a653b6e2dc8977e">More...</a><br /></td></tr>
<tr class="separator:ga08fe7335dd44017d8a653b6e2dc8977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236be57c231aa5433416bd60c887a14a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga236be57c231aa5433416bd60c887a14a">cpu_tsc_mark</a> (struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *mark)</td></tr>
<tr class="memdesc:ga236be57c231aa5433416bd60c887a14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store TSC and timing info.  <a href="group__libcpuid.html#ga236be57c231aa5433416bd60c887a14a">More...</a><br /></td></tr>
<tr class="separator:ga236be57c231aa5433416bd60c887a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69abf89db76d95039dc9338c4c5a697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gae69abf89db76d95039dc9338c4c5a697">cpu_tsc_unmark</a> (struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *mark)</td></tr>
<tr class="memdesc:gae69abf89db76d95039dc9338c4c5a697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate TSC and timing difference.  <a href="group__libcpuid.html#gae69abf89db76d95039dc9338c4c5a697">More...</a><br /></td></tr>
<tr class="separator:gae69abf89db76d95039dc9338c4c5a697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d3419eeac6d46d957875f1c302ca44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga55d3419eeac6d46d957875f1c302ca44">cpu_clock_by_mark</a> (struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *mark)</td></tr>
<tr class="memdesc:ga55d3419eeac6d46d957875f1c302ca44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the CPU clock.  <a href="group__libcpuid.html#ga55d3419eeac6d46d957875f1c302ca44">More...</a><br /></td></tr>
<tr class="separator:ga55d3419eeac6d46d957875f1c302ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14aec8ba2ccbda9ae385370a6bd5361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gae14aec8ba2ccbda9ae385370a6bd5361">cpu_clock_by_os</a> (void)</td></tr>
<tr class="memdesc:gae14aec8ba2ccbda9ae385370a6bd5361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock, as reported by the OS.  <a href="group__libcpuid.html#gae14aec8ba2ccbda9ae385370a6bd5361">More...</a><br /></td></tr>
<tr class="separator:gae14aec8ba2ccbda9ae385370a6bd5361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba20c7c72b6c943e0b3e664ede42b80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga6ba20c7c72b6c943e0b3e664ede42b80">cpu_clock_measure</a> (int millis, int quad_check)</td></tr>
<tr class="memdesc:ga6ba20c7c72b6c943e0b3e664ede42b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the CPU clock frequency.  <a href="group__libcpuid.html#ga6ba20c7c72b6c943e0b3e664ede42b80">More...</a><br /></td></tr>
<tr class="separator:ga6ba20c7c72b6c943e0b3e664ede42b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d23d7b9c774ad92b2d30a3798434224"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga4d23d7b9c774ad92b2d30a3798434224">cpu_clock_by_ic</a> (int millis, int runs)</td></tr>
<tr class="memdesc:ga4d23d7b9c774ad92b2d30a3798434224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the CPU clock frequency using instruction-counting.  <a href="group__libcpuid.html#ga4d23d7b9c774ad92b2d30a3798434224">More...</a><br /></td></tr>
<tr class="separator:ga4d23d7b9c774ad92b2d30a3798434224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913d86d69748e282f94ee4d28dca078c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga913d86d69748e282f94ee4d28dca078c">cpu_clock</a> (void)</td></tr>
<tr class="memdesc:ga913d86d69748e282f94ee4d28dca078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU clock frequency (all-in-one method)  <a href="group__libcpuid.html#ga913d86d69748e282f94ee4d28dca078c">More...</a><br /></td></tr>
<tr class="separator:ga913d86d69748e282f94ee4d28dca078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad973835515aa3b0d807b07279f03b965"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcpu__epc__t.html">cpu_epc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gad973835515aa3b0d807b07279f03b965">cpuid_get_epc</a> (int index, const struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *raw)</td></tr>
<tr class="memdesc:gad973835515aa3b0d807b07279f03b965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches information about an EPC (Enclave Page Cache) area.  <a href="group__libcpuid.html#gad973835515aa3b0d807b07279f03b965">More...</a><br /></td></tr>
<tr class="separator:gad973835515aa3b0d807b07279f03b965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0517d3660baee30704cc3a28b0b69d10"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga0517d3660baee30704cc3a28b0b69d10">cpuid_lib_version</a> (void)</td></tr>
<tr class="memdesc:ga0517d3660baee30704cc3a28b0b69d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the libcpuid version.  <a href="group__libcpuid.html#ga0517d3660baee30704cc3a28b0b69d10">More...</a><br /></td></tr>
<tr class="separator:ga0517d3660baee30704cc3a28b0b69d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa403016f62608ba42d910f7e560c2f2a"><td class="memItemLeft" align="right" valign="top">libcpuid_warn_fn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaa403016f62608ba42d910f7e560c2f2a">cpuid_set_warn_function</a> (libcpuid_warn_fn_t warn_fun)</td></tr>
<tr class="memdesc:gaa403016f62608ba42d910f7e560c2f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the warning print function.  <a href="group__libcpuid.html#gaa403016f62608ba42d910f7e560c2f2a">More...</a><br /></td></tr>
<tr class="separator:gaa403016f62608ba42d910f7e560c2f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97fe8a0702c19a1826cbfe8f69e5e264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga97fe8a0702c19a1826cbfe8f69e5e264">cpuid_set_verbosiness_level</a> (int level)</td></tr>
<tr class="memdesc:ga97fe8a0702c19a1826cbfe8f69e5e264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosiness level.  <a href="group__libcpuid.html#ga97fe8a0702c19a1826cbfe8f69e5e264">More...</a><br /></td></tr>
<tr class="separator:ga97fe8a0702c19a1826cbfe8f69e5e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b269fd7a481e1204bdc2bc0277cc47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga71b269fd7a481e1204bdc2bc0277cc47">cpuid_get_vendor</a> (void)</td></tr>
<tr class="memdesc:ga71b269fd7a481e1204bdc2bc0277cc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the CPU vendor from CPUID from the current CPU.  <a href="group__libcpuid.html#ga71b269fd7a481e1204bdc2bc0277cc47">More...</a><br /></td></tr>
<tr class="separator:ga71b269fd7a481e1204bdc2bc0277cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0131f6d12aca2d002175abcd9a1d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga1b0131f6d12aca2d002175abcd9a1d20">cpuid_get_cpu_list</a> (<a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a> vendor, struct <a class="el" href="structcpu__list__t.html">cpu_list_t</a> *list)</td></tr>
<tr class="memdesc:ga1b0131f6d12aca2d002175abcd9a1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of all known CPU names from a specific vendor.  <a href="group__libcpuid.html#ga1b0131f6d12aca2d002175abcd9a1d20">More...</a><br /></td></tr>
<tr class="separator:ga1b0131f6d12aca2d002175abcd9a1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe37f4d3025587d30ec82287ebfe236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga7fe37f4d3025587d30ec82287ebfe236">cpuid_free_cpu_list</a> (struct <a class="el" href="structcpu__list__t.html">cpu_list_t</a> *list)</td></tr>
<tr class="memdesc:ga7fe37f4d3025587d30ec82287ebfe236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a CPU list.  <a href="group__libcpuid.html#ga7fe37f4d3025587d30ec82287ebfe236">More...</a><br /></td></tr>
<tr class="separator:ga7fe37f4d3025587d30ec82287ebfe236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99453e100b3b502ca15b8a79198828a"><td class="memItemLeft" align="right" valign="top">struct msr_driver_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a">cpu_msr_driver_open</a> (void)</td></tr>
<tr class="memdesc:gab99453e100b3b502ca15b8a79198828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts/opens a driver, needed to read MSRs (Model Specific Registers)  <a href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a">More...</a><br /></td></tr>
<tr class="separator:gab99453e100b3b502ca15b8a79198828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238b88d0db89dc89d0d78fb27e06feb3"><td class="memItemLeft" align="right" valign="top">struct msr_driver_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga238b88d0db89dc89d0d78fb27e06feb3">cpu_msr_driver_open_core</a> (unsigned core_num)</td></tr>
<tr class="memdesc:ga238b88d0db89dc89d0d78fb27e06feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a">cpu_msr_driver_open</a>, but accept one parameter.  <a href="group__libcpuid.html#ga238b88d0db89dc89d0d78fb27e06feb3">More...</a><br /></td></tr>
<tr class="separator:ga238b88d0db89dc89d0d78fb27e06feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eddf30c99a094aa9942265948a13007"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#ga0eddf30c99a094aa9942265948a13007">cpu_rdmsr</a> (struct msr_driver_t *handle, uint32_t msr_index, uint64_t *result)</td></tr>
<tr class="memdesc:ga0eddf30c99a094aa9942265948a13007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a Model-Specific Register (MSR)  <a href="group__libcpuid.html#ga0eddf30c99a094aa9942265948a13007">More...</a><br /></td></tr>
<tr class="separator:ga0eddf30c99a094aa9942265948a13007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2056d06fd9ea3338535157e40ca6359"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gae2056d06fd9ea3338535157e40ca6359">cpu_rdmsr_range</a> (struct msr_driver_t *handle, uint32_t msr_index, uint8_t highbit, uint8_t lowbit, uint64_t *result)</td></tr>
<tr class="memdesc:gae2056d06fd9ea3338535157e40ca6359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__libcpuid.html#ga0eddf30c99a094aa9942265948a13007">cpu_rdmsr</a>, but extract a range of bits.  <a href="group__libcpuid.html#gae2056d06fd9ea3338535157e40ca6359">More...</a><br /></td></tr>
<tr class="separator:gae2056d06fd9ea3338535157e40ca6359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac977cbb78e00058098778411d7f784cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gac977cbb78e00058098778411d7f784cf">cpu_msrinfo</a> (struct msr_driver_t *handle, <a class="el" href="group__libcpuid.html#ga0e38033529430a12f20089b382d603a6">cpu_msrinfo_request_t</a> which)</td></tr>
<tr class="memdesc:gac977cbb78e00058098778411d7f784cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads extended CPU information from Model-Specific Registers.  <a href="group__libcpuid.html#gac977cbb78e00058098778411d7f784cf">More...</a><br /></td></tr>
<tr class="separator:gac977cbb78e00058098778411d7f784cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b1d6fc07f6019f0912057a2320c3e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaa7b1d6fc07f6019f0912057a2320c3e6">msr_serialize_raw_data</a> (struct msr_driver_t *handle, const char *filename)</td></tr>
<tr class="memdesc:gaa7b1d6fc07f6019f0912057a2320c3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the raw MSR data to a text file.  <a href="group__libcpuid.html#gaa7b1d6fc07f6019f0912057a2320c3e6">More...</a><br /></td></tr>
<tr class="separator:gaa7b1d6fc07f6019f0912057a2320c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84c8636236dacb88fc06f987dcae766"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libcpuid.html#gaf84c8636236dacb88fc06f987dcae766">cpu_msr_driver_close</a> (struct msr_driver_t *handle)</td></tr>
<tr class="memdesc:gaf84c8636236dacb88fc06f987dcae766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open MSR driver.  <a href="group__libcpuid.html#gaf84c8636236dacb88fc06f987dcae766">More...</a><br /></td></tr>
<tr class="separator:gaf84c8636236dacb88fc06f987dcae766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>LibCPUID provides CPU identification. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaaaad3aee57ed8705424f5884fb15849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaad3aee57ed8705424f5884fb15849f">&#9670;&nbsp;</a></span>cpu_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f">cpu_error_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes common library error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849faa26c163b80b1f6786ca81dadc14b00fb"></a>ERR_OK&#160;</td><td class="fielddoc"><p>No error </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa606d51bab169e05a118d986f34e2ac24"></a>ERR_NO_CPUID&#160;</td><td class="fielddoc"><p>CPUID instruction is not supported </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa97b10b1d6816df08f3d6ac947c7177e0"></a>ERR_NO_RDTSC&#160;</td><td class="fielddoc"><p>RDTSC instruction is not supported </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa1859972576f52b73a9661d101a6328a1"></a>ERR_NO_MEM&#160;</td><td class="fielddoc"><p>Memory allocation failed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa7235954be32cd0166432c3f7a5d61bb5"></a>ERR_OPEN&#160;</td><td class="fielddoc"><p>File open operation failed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa0dd33d6ae54908e2f361f9f0bc7cf64f"></a>ERR_BADFMT&#160;</td><td class="fielddoc"><p>Bad file format </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa6ba069bd5e69d2abb4b0afd1ee2637e8"></a>ERR_NOT_IMP&#160;</td><td class="fielddoc"><p>Not implemented </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa231b5ba999016056b60e42d7e50efb2e"></a>ERR_CPU_UNKN&#160;</td><td class="fielddoc"><p>Unsupported processor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa379883983dfe8ed4433d1ea5abf37d1d"></a>ERR_NO_RDMSR&#160;</td><td class="fielddoc"><p>RDMSR instruction is not supported </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa87e406a43767ad4c28a746e6bc3a1112"></a>ERR_NO_DRIVER&#160;</td><td class="fielddoc"><p>RDMSR driver error (generic) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa1a2c6d04958fb4436318f6460e1b5f1b"></a>ERR_NO_PERMS&#160;</td><td class="fielddoc"><p>No permissions to install RDMSR driver </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849faad3e8c13adfc55ea1cd105e92972dd33"></a>ERR_EXTRACT&#160;</td><td class="fielddoc"><p>Cannot extract RDMSR driver (read only media?) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fad84654b76a5ac772f3463e055702a360"></a>ERR_HANDLE&#160;</td><td class="fielddoc"><p>Bad handle </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa666f5844a2eeffd7f4e3333e4bfd0d6a"></a>ERR_INVMSR&#160;</td><td class="fielddoc"><p>Invalid MSR </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fad0b3acac21097e986877db7c9f9f631b"></a>ERR_INVCNB&#160;</td><td class="fielddoc"><p>Invalid core number </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fac00bab796cfece6df01a01538b7f5b17"></a>ERR_HANDLE_R&#160;</td><td class="fielddoc"><p>Error on handle read </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaaad3aee57ed8705424f5884fb15849fa717b2cb8ca3bcc737f8c76ee657558ae"></a>ERR_INVRANGE&#160;</td><td class="fielddoc"><p>Invalid given range </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4c0b398deee739a645387c7329a4c289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0b398deee739a645387c7329a4c289">&#9670;&nbsp;</a></span>cpu_feature_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#ga4c0b398deee739a645387c7329a4c289">cpu_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU feature identifiers. </p>
<p>Usage: </p><div class="fragment"><div class="line">...</div>
<div class="line">struct <a class="code" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> raw;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structcpu__id__t.html">cpu_id_t</a> id;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746">cpuid_get_raw_data</a>(&amp;raw) == 0 &amp;&amp; <a class="code" href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e">cpu_identify</a>(&amp;raw, &amp;<span class="keywordtype">id</span>) == 0) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.<a class="code" href="structcpu__id__t.html#afe7f0f779b5986f1a89f02aa53d842a8">flags</a>[<a class="code" href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4256f8c13070e3b8bd6be3010a5c1226">CPU_FEATURE_SSE2</a>]) {</div>
<div class="line">        <span class="comment">// The CPU has SSE2...</span></div>
<div class="line">        ...</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// no SSE2</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// processor cannot be determined.</span></div>
<div class="line">}</div>
</div><!-- fragment --> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a453849150533658bb299b8a6dceb4363"></a>CPU_FEATURE_FPU&#160;</td><td class="fielddoc"><p>Floating point unit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a25f411f7e138c5d268e70045c6158329"></a>CPU_FEATURE_VME&#160;</td><td class="fielddoc"><p>Virtual mode extension </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ab562af0f4bc281ff2ee36b122ff88058"></a>CPU_FEATURE_DE&#160;</td><td class="fielddoc"><p>Debugging extension </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a55fdf1520915f360865af0e33769845e"></a>CPU_FEATURE_PSE&#160;</td><td class="fielddoc"><p>Page size extension </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a48ff7bd2f3e866b0cc33591a49f52e73"></a>CPU_FEATURE_TSC&#160;</td><td class="fielddoc"><p>Time-stamp counter </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a1865c515f1dfe0e7d6a57827fc83cbd9"></a>CPU_FEATURE_MSR&#160;</td><td class="fielddoc"><p>Model-specific regsisters, RDMSR/WRMSR supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289acc96bbaefe5f0d4d11dbe191dc8926f4"></a>CPU_FEATURE_PAE&#160;</td><td class="fielddoc"><p>Physical address extension </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a17ec983ccfddedbc7a9b00d20a665685"></a>CPU_FEATURE_MCE&#160;</td><td class="fielddoc"><p>Machine check exception </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8f942324f3c7e6b2977a0799736b8874"></a>CPU_FEATURE_CX8&#160;</td><td class="fielddoc"><p>CMPXCHG8B instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a1acd5ed0fd11f8181ee5355620d1df31"></a>CPU_FEATURE_APIC&#160;</td><td class="fielddoc"><p>APIC support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa385b21280ba8b58e96e4cf93b21f21e"></a>CPU_FEATURE_MTRR&#160;</td><td class="fielddoc"><p>Memory type range registers </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a3390256a622bd4baf24e023b99515fde"></a>CPU_FEATURE_SEP&#160;</td><td class="fielddoc"><p>SYSENTER / SYSEXIT instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ac0244dd1443fcf61782e534a964b2cb8"></a>CPU_FEATURE_PGE&#160;</td><td class="fielddoc"><p>Page global enable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ac869b2e0261d320839fc87bebddf2734"></a>CPU_FEATURE_MCA&#160;</td><td class="fielddoc"><p>Machine check architecture </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa52edbfedff12ef2634779677d2616de"></a>CPU_FEATURE_CMOV&#160;</td><td class="fielddoc"><p>CMOVxx instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a90640b8f73923c881388e796b46d0f61"></a>CPU_FEATURE_PAT&#160;</td><td class="fielddoc"><p>Page attribute table </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a5ac632d942e4e05daea1277e4a9501d4"></a>CPU_FEATURE_PSE36&#160;</td><td class="fielddoc"><p>36-bit page address extension </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289adf54ae06b9144822b18aad09b56aa24f"></a>CPU_FEATURE_PN&#160;</td><td class="fielddoc"><p>Processor serial # implemented (Intel P3 only) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a3a9f860c11b538507396b52d9b87103a"></a>CPU_FEATURE_CLFLUSH&#160;</td><td class="fielddoc"><p>CLFLUSH instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289af2c956245b6c27448453374f5f3835de"></a>CPU_FEATURE_DTS&#160;</td><td class="fielddoc"><p>Debug store supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a3cca7d5d4dbba92daf3458e925363004"></a>CPU_FEATURE_ACPI&#160;</td><td class="fielddoc"><p>ACPI support (power states) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a85890ccf3243ad847a94c4af7d74f5bb"></a>CPU_FEATURE_MMX&#160;</td><td class="fielddoc"><p>MMX instruction set supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ae9a107e859c13e63568f820bcd9c85ad"></a>CPU_FEATURE_FXSR&#160;</td><td class="fielddoc"><p>FXSAVE / FXRSTOR supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa68e99c4dc5a309e093e9dfa72bb39ca"></a>CPU_FEATURE_SSE&#160;</td><td class="fielddoc"><p>Streaming-SIMD Extensions (SSE) supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a4256f8c13070e3b8bd6be3010a5c1226"></a>CPU_FEATURE_SSE2&#160;</td><td class="fielddoc"><p>SSE2 instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289abb1a066840045516b62bcaa0abf8f654"></a>CPU_FEATURE_SS&#160;</td><td class="fielddoc"><p>Self-snoop </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a67dfcf32f2458471da57a087220566ac"></a>CPU_FEATURE_HT&#160;</td><td class="fielddoc"><p>Hyper-threading supported (but might be disabled) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a41a6517364e91773f80379a00a4cc926"></a>CPU_FEATURE_TM&#160;</td><td class="fielddoc"><p>Thermal monitor </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ae035f6e3adc1cb92a313792cdd074e72"></a>CPU_FEATURE_IA64&#160;</td><td class="fielddoc"><p>IA64 supported (Itanium only) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aeb144ddd3365cba1798b3c32a09089a9"></a>CPU_FEATURE_PBE&#160;</td><td class="fielddoc"><p>Pending-break enable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a2000e3d103c50e66ae00f59d8adcc355"></a>CPU_FEATURE_PNI&#160;</td><td class="fielddoc"><p>PNI (SSE3) instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a4fbe032106b78197602cc65e38499524"></a>CPU_FEATURE_PCLMUL&#160;</td><td class="fielddoc"><p>PCLMULQDQ instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ad37850e3455312b32bdfa815cdd860b7"></a>CPU_FEATURE_DTS64&#160;</td><td class="fielddoc"><p>64-bit Debug store supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a1b9e596067a149fd5d4e8f5ccf5ed5d1"></a>CPU_FEATURE_MONITOR&#160;</td><td class="fielddoc"><p>MONITOR / MWAIT supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ab84f0cfd4a8e324f180017c3e390f82d"></a>CPU_FEATURE_DS_CPL&#160;</td><td class="fielddoc"><p>CPL Qualified Debug Store </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a3575a558eccc8193a1d8fe8f74a30152"></a>CPU_FEATURE_VMX&#160;</td><td class="fielddoc"><p>Virtualization technology supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a89f81845a90b08193b19352f75787cf9"></a>CPU_FEATURE_SMX&#160;</td><td class="fielddoc"><p>Safer mode exceptions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a7a4eb4645b87f3e1f71a757652278afd"></a>CPU_FEATURE_EST&#160;</td><td class="fielddoc"><p>Enhanced SpeedStep </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a96f6a665327dda077698d896a52f9ec0"></a>CPU_FEATURE_TM2&#160;</td><td class="fielddoc"><p>Thermal monitor 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a7d6981f45c7c0782c35ed3a2e7a1360c"></a>CPU_FEATURE_SSSE3&#160;</td><td class="fielddoc"><p>SSSE3 instructionss supported (this is different from SSE3!) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a55ca5e131471a2da71b80f0cd4606063"></a>CPU_FEATURE_CID&#160;</td><td class="fielddoc"><p>Context ID supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a46b3cc99edc475b1af401ce11bb74f72"></a>CPU_FEATURE_CX16&#160;</td><td class="fielddoc"><p>CMPXCHG16B instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ae4a1cf449ea63c0fd241eb71de6241d8"></a>CPU_FEATURE_XTPR&#160;</td><td class="fielddoc"><p>Send Task Priority Messages disable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a98bfdf89c13198320684165a90bdf823"></a>CPU_FEATURE_PDCM&#160;</td><td class="fielddoc"><p>Performance capabilities MSR supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8e37ce7e2ac8218888431702e6206f85"></a>CPU_FEATURE_DCA&#160;</td><td class="fielddoc"><p>Direct cache access supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8608d346e0c702d740d03ce42c87f186"></a>CPU_FEATURE_SSE4_1&#160;</td><td class="fielddoc"><p>SSE 4.1 instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a24c4a542403f6a3399d58ecf7bbe2493"></a>CPU_FEATURE_SSE4_2&#160;</td><td class="fielddoc"><p>SSE 4.2 instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a6415775054c1b1225d286ebf6b2b873b"></a>CPU_FEATURE_SYSCALL&#160;</td><td class="fielddoc"><p>SYSCALL / SYSRET instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ad0aadd272ee5f176561d19b630ccd0ab"></a>CPU_FEATURE_XD&#160;</td><td class="fielddoc"><p>Execute disable bit supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289acafda352a331b5091996f50ca62ec404"></a>CPU_FEATURE_MOVBE&#160;</td><td class="fielddoc"><p>MOVBE instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8a950b6d548ea934f26e1f8118d284f6"></a>CPU_FEATURE_POPCNT&#160;</td><td class="fielddoc"><p>POPCNT instruction supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ae612eb3cc570f400c2542c0de6b6079d"></a>CPU_FEATURE_AES&#160;</td><td class="fielddoc"><p>AES* instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a490e07c3f0e90180e2fe3d833f7fc00a"></a>CPU_FEATURE_XSAVE&#160;</td><td class="fielddoc"><p>XSAVE/XRSTOR/etc instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a52f44e2b623c249be3bdeee523221e92"></a>CPU_FEATURE_OSXSAVE&#160;</td><td class="fielddoc"><p>non-privileged copy of OSXSAVE supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289acfd03e7e97fa2fcf234cf88dd250eaa5"></a>CPU_FEATURE_AVX&#160;</td><td class="fielddoc"><p>Advanced vector extensions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ace6439b05c8e49701e281fab54adef47"></a>CPU_FEATURE_MMXEXT&#160;</td><td class="fielddoc"><p>AMD MMX-extended instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ad196550729f133d1a5a5ad2372a1d36f"></a>CPU_FEATURE_3DNOW&#160;</td><td class="fielddoc"><p>AMD 3DNow! instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a63bad125f7d98decb95f8f7caa6ab382"></a>CPU_FEATURE_3DNOWEXT&#160;</td><td class="fielddoc"><p>AMD 3DNow! extended instructions supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a4bd0778d9173fedb1901455d04d5d625"></a>CPU_FEATURE_NX&#160;</td><td class="fielddoc"><p>No-execute bit supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ac8cf5bd2c03e7cbebd5c9b92ca048809"></a>CPU_FEATURE_FXSR_OPT&#160;</td><td class="fielddoc"><p>FFXSR: FXSAVE and FXRSTOR optimizations </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a9bc3a4d9d238ae8a0827b206ad8914d9"></a>CPU_FEATURE_RDTSCP&#160;</td><td class="fielddoc"><p>RDTSCP instruction supported (AMD-only) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289acc02143e1c19a07321131d2435f98cae"></a>CPU_FEATURE_LM&#160;</td><td class="fielddoc"><p>Long mode (x86_64/EM64T) supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8d6f0cef0aaa5ae341bd9a57e5c2f453"></a>CPU_FEATURE_LAHF_LM&#160;</td><td class="fielddoc"><p>LAHF/SAHF supported in 64-bit mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a518d74659dc7c7f6c6286e8b7af5b2f4"></a>CPU_FEATURE_CMP_LEGACY&#160;</td><td class="fielddoc"><p>core multi-processing legacy mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a4f10a68bc2590a75ec9cd1079c137f97"></a>CPU_FEATURE_SVM&#160;</td><td class="fielddoc"><p>AMD Secure virtual machine </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a65f25f348ca56a8acf114125021cc61f"></a>CPU_FEATURE_ABM&#160;</td><td class="fielddoc"><p>LZCNT instruction support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289af7d43dab2ccad4c9aaae131adb16d24d"></a>CPU_FEATURE_MISALIGNSSE&#160;</td><td class="fielddoc"><p>Misaligned SSE supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa452c85116a8be446cd76e14a15d5398"></a>CPU_FEATURE_SSE4A&#160;</td><td class="fielddoc"><p>SSE 4a from AMD </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa713ac40f60eb9879f3d67d0c76f67b6"></a>CPU_FEATURE_3DNOWPREFETCH&#160;</td><td class="fielddoc"><p>PREFETCH/PREFETCHW support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a622ddfde42bdf056fb833f3ea1db6a49"></a>CPU_FEATURE_OSVW&#160;</td><td class="fielddoc"><p>OS Visible Workaround (AMD) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ac5366b66425729071fe5e2a2728de632"></a>CPU_FEATURE_IBS&#160;</td><td class="fielddoc"><p>Instruction-based sampling </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a179c10fda2621f4cfc6426d988da0876"></a>CPU_FEATURE_SSE5&#160;</td><td class="fielddoc"><p>SSE 5 instructions supported (deprecated, will never be 1) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a21cb4bb1b77f8a24873c6b7974efc704"></a>CPU_FEATURE_SKINIT&#160;</td><td class="fielddoc"><p>SKINIT / STGI supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aa1758a8841c2267e8581e5228491ca3d"></a>CPU_FEATURE_WDT&#160;</td><td class="fielddoc"><p>Watchdog timer support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a664c7e2732b847819c1a000717da652e"></a>CPU_FEATURE_TS&#160;</td><td class="fielddoc"><p>Temperature sensor </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a2242333b009477a54a5807e9b972086a"></a>CPU_FEATURE_FID&#160;</td><td class="fielddoc"><p>Frequency ID control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a92fc0b056726842599cc54bd90b1a0be"></a>CPU_FEATURE_VID&#160;</td><td class="fielddoc"><p>Voltage ID control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a27c791308415baaba9f751238b9f86ea"></a>CPU_FEATURE_TTP&#160;</td><td class="fielddoc"><p>THERMTRIP </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ab79d96191ba266776b55b54818b66cd5"></a>CPU_FEATURE_TM_AMD&#160;</td><td class="fielddoc"><p>AMD-specified hardware thermal control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a26051b02eb1bd376da9e889bb9b8b154"></a>CPU_FEATURE_STC&#160;</td><td class="fielddoc"><p>Software thermal control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a470838a8e63aca9a48b3f3c33030cc54"></a>CPU_FEATURE_100MHZSTEPS&#160;</td><td class="fielddoc"><p>100 MHz multiplier control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a2cb12da6a5c22a8cf496137c2a1c368b"></a>CPU_FEATURE_HWPSTATE&#160;</td><td class="fielddoc"><p>Hardware P-state control </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a839020f8c8739dc5d753581205a94597"></a>CPU_FEATURE_CONSTANT_TSC&#160;</td><td class="fielddoc"><p>TSC ticks at constant rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a567aa09c705213218b85b78c8f6441a9"></a>CPU_FEATURE_XOP&#160;</td><td class="fielddoc"><p>The XOP instruction set (same as the old CPU_FEATURE_SSE5) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289abfcf54efabb2bfef6912b82b5b40f69d"></a>CPU_FEATURE_FMA3&#160;</td><td class="fielddoc"><p>The FMA3 instruction set </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a43059146e6421866ef8011958f7f2572"></a>CPU_FEATURE_FMA4&#160;</td><td class="fielddoc"><p>The FMA4 instruction set </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289adf4ac8554a8467a61970083a54166340"></a>CPU_FEATURE_TBM&#160;</td><td class="fielddoc"><p>Trailing bit manipulation instruction support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289afeda100f9de3f9e880c75593d3ac948c"></a>CPU_FEATURE_F16C&#160;</td><td class="fielddoc"><p>16-bit FP convert instruction support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a1e7557ccde6b429df4532384a1fa9f82"></a>CPU_FEATURE_RDRAND&#160;</td><td class="fielddoc"><p>RdRand instruction </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a6b31b846f054bbec14f8569a6086b00b"></a>CPU_FEATURE_X2APIC&#160;</td><td class="fielddoc"><p>x2APIC, APIC_BASE.EXTD, MSRs 0000_0800h...0000_0BFFh 64-bit ICR (+030h but not +031h), no DFR (+00Eh), SELF_IPI (+040h) also see standard level 0000_000Bh </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289afa0842a9b99f9f77920239127c922d1c"></a>CPU_FEATURE_CPB&#160;</td><td class="fielddoc"><p>Core performance boost </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8366a2ebea8cce37a8f9d921425ea09b"></a>CPU_FEATURE_APERFMPERF&#160;</td><td class="fielddoc"><p>MPERF/APERF MSRs support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289adfd99dbe1be50fa605c08b82fc85b8b8"></a>CPU_FEATURE_PFI&#160;</td><td class="fielddoc"><p>Processor Feedback Interface support </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aaeafcab708552f1e8aef36735e880c51"></a>CPU_FEATURE_PA&#160;</td><td class="fielddoc"><p>Processor accumulator </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a18394e14e517073195b57ec9aee5ea15"></a>CPU_FEATURE_AVX2&#160;</td><td class="fielddoc"><p>AVX2 instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aea28e9015a5fa858eb34732881705450"></a>CPU_FEATURE_BMI1&#160;</td><td class="fielddoc"><p>BMI1 instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ab83da08aec73311f80d303beadd14682"></a>CPU_FEATURE_BMI2&#160;</td><td class="fielddoc"><p>BMI2 instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a9f78f8ffbcc16a647381a4a48929e300"></a>CPU_FEATURE_HLE&#160;</td><td class="fielddoc"><p>Hardware Lock Elision prefixes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a2772648837f617553ba3e441b760a341"></a>CPU_FEATURE_RTM&#160;</td><td class="fielddoc"><p>Restricted Transactional Memory instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a87a7473d47e00e1cf07a424728ad1b67"></a>CPU_FEATURE_AVX512F&#160;</td><td class="fielddoc"><p>AVX-512 Foundation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a8814d6aa3b83f4c857f857a73952c4a4"></a>CPU_FEATURE_AVX512DQ&#160;</td><td class="fielddoc"><p>AVX-512 Double/Quad granular insns </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a36ef43b0a41b9866757a3b3984197fbe"></a>CPU_FEATURE_AVX512PF&#160;</td><td class="fielddoc"><p>AVX-512 Prefetch </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a5fc80b7adcd252d915a9c4fc850b8268"></a>CPU_FEATURE_AVX512ER&#160;</td><td class="fielddoc"><p>AVX-512 Exponential/Reciprocal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289ae901d15aac437570fc9f7cbddfdbafa2"></a>CPU_FEATURE_AVX512CD&#160;</td><td class="fielddoc"><p>AVX-512 Conflict detection </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a650d153fab53759e4ea1a187effa9c8a"></a>CPU_FEATURE_SHA_NI&#160;</td><td class="fielddoc"><p>SHA-1/SHA-256 instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a3463b7c5837d2034380ef8b0c8ba9a8c"></a>CPU_FEATURE_AVX512BW&#160;</td><td class="fielddoc"><p>AVX-512 Byte/Word granular insns </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289add282121c269c2763a1f7b1d3358b7cf"></a>CPU_FEATURE_AVX512VL&#160;</td><td class="fielddoc"><p>AVX-512 128/256 vector length extensions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a26c943581012c705d53af5800af60d16"></a>CPU_FEATURE_SGX&#160;</td><td class="fielddoc"><p>SGX extensions. Non-autoritative, check cpu_id_t::sgx::present to verify presence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a9bf2318b5d28e37ad55b055692508c58"></a>CPU_FEATURE_RDSEED&#160;</td><td class="fielddoc"><p>RDSEED instruction </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289a78800c3a6afc1cc3bcc5cf7b337e5e9a"></a>CPU_FEATURE_ADX&#160;</td><td class="fielddoc"><p>ADX extensions (arbitrary precision) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4c0b398deee739a645387c7329a4c289aeb7e119b120a657920fc1e5214e36b0c"></a>CPU_FEATURE_AVX512VNNI&#160;</td><td class="fielddoc"><p>AVX-512 Vector Neural Network Instructions </p>
</td></tr>
</table>

</div>
</div>
<a id="gada395ff8a06f8f37d09a4a07926aa661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada395ff8a06f8f37d09a4a07926aa661">&#9670;&nbsp;</a></span>cpu_hint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#gada395ff8a06f8f37d09a4a07926aa661">cpu_hint_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU detection hints identifiers. </p>
<p>Usage: similar to the flags usage </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada395ff8a06f8f37d09a4a07926aa661a590d513544b1eb01e67751085f22e1eb"></a>CPU_HINT_SSE_SIZE_AUTH&#160;</td><td class="fielddoc"><p>SSE unit size is authoritative (not only a Family/Model guesswork, but based on an actual CPUID bit) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0e38033529430a12f20089b382d603a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e38033529430a12f20089b382d603a6">&#9670;&nbsp;</a></span>cpu_msrinfo_request_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#ga0e38033529430a12f20089b382d603a6">cpu_msrinfo_request_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6a6341e3edd069ee19e9f74bdc0d6207fe"></a>INFO_MPERF&#160;</td><td class="fielddoc"><p>Maximum performance frequency clock. This is a counter, which increments as a proportion of the actual processor speed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6ad366b181e477c5003915ddd6dd97a46b"></a>INFO_APERF&#160;</td><td class="fielddoc"><p>Actual performance frequency clock. This accumulates the core clock counts when the core is active. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6a252a37590925f8b5b01fbd29984b2b2a"></a>INFO_MIN_MULTIPLIER&#160;</td><td class="fielddoc"><p>Minimum CPU:FSB ratio for this CPU, multiplied by 100. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6aa5299acc66aaa3426e921658d2a318d9"></a>INFO_CUR_MULTIPLIER&#160;</td><td class="fielddoc"><p>Current CPU:FSB ratio, multiplied by 100. e.g., a CPU:FSB value of 18.5 reads as "1850". </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6aef85eba90772abc57cb874aeacfb0f9d"></a>INFO_MAX_MULTIPLIER&#160;</td><td class="fielddoc"><p>Maximum CPU:FSB ratio for this CPU, multiplied by 100. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6ae8f05f1a8766aa8fec25051e5fffefe2"></a>INFO_TEMPERATURE&#160;</td><td class="fielddoc"><p>The current core temperature in Celsius. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6a6f67768463665d06172cebe58c9b02af"></a>INFO_THROTTLING&#160;</td><td class="fielddoc"><p>1 if the current logical processor is throttling. 0 if it is running normally. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6a8b113e4509ae0df8110230fca5ec8266"></a>INFO_VOLTAGE&#160;</td><td class="fielddoc"><p>The current core voltage in Volt, multiplied by 100. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6a1128829d5c5e8b2cab03e0ab93127f8b"></a>INFO_BCLK&#160;</td><td class="fielddoc"><p>See <a class="el" href="group__libcpuid.html#gga0e38033529430a12f20089b382d603a6ae8599601c81d3fdc60c353fc95775f14">INFO_BUS_CLOCK</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0e38033529430a12f20089b382d603a6ae8599601c81d3fdc60c353fc95775f14"></a>INFO_BUS_CLOCK&#160;</td><td class="fielddoc"><p>The main bus clock in MHz, e.g., FSB/QPI/DMI/HT base clock, multiplied by 100. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab7731d6f7447310c9a29d2c92c867d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7731d6f7447310c9a29d2c92c867d4f">&#9670;&nbsp;</a></span>cpu_sgx_feature_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#gab7731d6f7447310c9a29d2c92c867d4f">cpu_sgx_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGX features flags. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcpu__sgx__t.html" title="This contains information about SGX features of the processor Example usage:">cpu_sgx_t</a></dd></dl>
<p>Usage: </p><div class="fragment"><div class="line">...</div>
<div class="line">struct <a class="code" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> raw;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structcpu__id__t.html">cpu_id_t</a> id;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746">cpuid_get_raw_data</a>(&amp;raw) == 0 &amp;&amp; <a class="code" href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e">cpu_identify</a>(&amp;raw, &amp;<span class="keywordtype">id</span>) == 0 &amp;&amp; <span class="keywordtype">id</span>.<a class="code" href="structcpu__id__t.html#a89b162728b0d5dbaf7b3169b2096ecbc">sgx</a>.<a class="code" href="structcpu__sgx__t.html#a9e44e3fb6976c51439d5acb01024e8c2">present</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.<a class="code" href="structcpu__id__t.html#a89b162728b0d5dbaf7b3169b2096ecbc">sgx</a>.<a class="code" href="structcpu__sgx__t.html#a4e61408256b02bf7b7a11f8a138c4d64">flags</a>[<a class="code" href="group__libcpuid.html#ggab7731d6f7447310c9a29d2c92c867d4fa09de49d5e0772b8ee6e232f9aeefcf25">INTEL_SGX1</a>])</div>
<div class="line">        <span class="comment">// The CPU has SGX1 instructions support...</span></div>
<div class="line">        ...</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// no SGX</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// processor cannot be determined.</span></div>
<div class="line">}</div>
</div><!-- fragment --> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab7731d6f7447310c9a29d2c92c867d4fa09de49d5e0772b8ee6e232f9aeefcf25"></a>INTEL_SGX1&#160;</td><td class="fielddoc"><p>SGX1 instructions support </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab7731d6f7447310c9a29d2c92c867d4fa2943256b42664d19b46a7f086dab3488"></a>INTEL_SGX2&#160;</td><td class="fielddoc"><p>SGX2 instructions support </p>
</td></tr>
</table>

</div>
</div>
<a id="gaee3591049f485bb93dbd26dd91684d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3591049f485bb93dbd26dd91684d28">&#9670;&nbsp;</a></span>cpu_vendor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU vendor, as guessed from the Vendor String. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a0ff85c91faaad5edc40b8b13bf5872a9"></a>VENDOR_INTEL&#160;</td><td class="fielddoc"><p>Intel CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a98f56d8179428f9ae8a673281e490fb7"></a>VENDOR_AMD&#160;</td><td class="fielddoc"><p>AMD CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28ad78b1b4a1b336bba96d40cb511ca0739"></a>VENDOR_CYRIX&#160;</td><td class="fielddoc"><p>Cyrix CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a0bbc1eea1798b997ef8a48c61eb87127"></a>VENDOR_NEXGEN&#160;</td><td class="fielddoc"><p>NexGen CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28ae0f24610ed6f971e45376b01249400f2"></a>VENDOR_TRANSMETA&#160;</td><td class="fielddoc"><p>Transmeta CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a71ab6d3938d2ea3f53faf7583fb75314"></a>VENDOR_UMC&#160;</td><td class="fielddoc"><p>x86 CPU by UMC </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28aca19c521336c04c427d4bd4efcf20c88"></a>VENDOR_CENTAUR&#160;</td><td class="fielddoc"><p>x86 CPU by IDT </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a38cda576d1ef80f226b84c2c726fcaf4"></a>VENDOR_RISE&#160;</td><td class="fielddoc"><p>x86 CPU by Rise Technology </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a47ddfbe49b7c864e04acd13af0b384fb"></a>VENDOR_SIS&#160;</td><td class="fielddoc"><p>x86 CPU by SiS </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28aaaee595f5e3f1e06a5fa7a418aafe9c0"></a>VENDOR_NSC&#160;</td><td class="fielddoc"><p>x86 CPU by National Semiconductor </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28acdf07de1723fc7e21a80f5d4053ef150"></a>VENDOR_HYGON&#160;</td><td class="fielddoc"><p>Hygon CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaee3591049f485bb93dbd26dd91684d28a44775e86f4d8a7e1ca5f62175ff6f486"></a>NUM_CPU_VENDORS&#160;</td><td class="fielddoc"><p>Valid CPU vendor ids: 0..NUM_CPU_VENDORS - 1 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga913d86d69748e282f94ee4d28dca078c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913d86d69748e282f94ee4d28dca078c">&#9670;&nbsp;</a></span>cpu_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU clock frequency (all-in-one method) </p>
<p>This is an all-in-one method for getting the CPU clock frequency. It tries to use the OS for that. If the OS doesn't have this info, it uses cpu_clock_measure with 200ms time interval and quadruple checking.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU clock frequency in MHz. If every possible method fails, the result is -1. </dd></dl>

</div>
</div>
<a id="ga4d23d7b9c774ad92b2d30a3798434224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d23d7b9c774ad92b2d30a3798434224">&#9670;&nbsp;</a></span>cpu_clock_by_ic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_clock_by_ic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>runs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the CPU clock frequency using instruction-counting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millis</td><td>- how much time to allocate for each run, in milliseconds </td></tr>
    <tr><td class="paramname">runs</td><td>- how many runs to perform</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs a busy-wait cycle using a known number of "heavy" (SSE) instructions. These instructions run at (more or less guaranteed) 1 IPC rate, so by running a busy loop for a fixed amount of time, and measuring the amount of instructions done, the CPU clock is accurately measured.</p>
<p>Of course, this function is still affected by the power-saving schemes, so the warnings as of <a class="el" href="group__libcpuid.html#ga6ba20c7c72b6c943e0b3e664ede42b80" title="Measure the CPU clock frequency.">cpu_clock_measure()</a> still apply. However, this function is immune to problems with detection, related to the Intel Nehalem's "Turbo" mode, where the internal clock is raised, but the RDTSC rate is unaffected.</p>
<p>The function will run for about (millis * runs) milliseconds. You can make only a single busy-wait run (runs == 1); however, this can be affected by task scheduling (which will break the counting), so allowing more than one run is recommended. As run length is not imperative for accurate readings (e.g., 50ms is sufficient), you can afford a lot of short runs, e.g. 10 runs of 50ms or 20 runs of 25ms.</p>
<p>Recommended values - millis = 50, runs = 4. For more robustness, increase the number of runs.</p>
<p>NOTE: on Bulldozer and later CPUs, the busy-wait cycle runs at 1.4 IPC, thus the results are skewed. This is corrected internally by dividing the resulting value by 1.4. However, this only occurs if the thread is executed on a single CMT module - if there are other threads competing for resources, the results are unpredictable. Make sure you run <a class="el" href="group__libcpuid.html#ga4d23d7b9c774ad92b2d30a3798434224" title="Measure the CPU clock frequency using instruction-counting.">cpu_clock_by_ic()</a> on a CPU that is free from competing threads, or if there are such threads, they shouldn't exceed the number of modules. On a Bulldozer X8, that means 4 threads.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU clock frequency in MHz (within some measurement error margin). If SSE is not supported, the result is -1. If the input parameters are incorrect, or some other internal fault is detected, the result is -2. </dd></dl>

</div>
</div>
<a id="ga55d3419eeac6d46d957875f1c302ca44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55d3419eeac6d46d957875f1c302ca44">&#9670;&nbsp;</a></span>cpu_clock_by_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_clock_by_mark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the CPU clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>- pointer to a <a class="el" href="structcpu__mark__t.html" title="Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.">cpu_mark_t</a> structure, which has been initialized with cpu_tsc_mark and later &lsquo;stopped&rsquo; with cpu_tsc_unmark.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For reliable results, the marked time interval should be at least about 10 ms.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the CPU clock frequency, in MHz. Due to measurement error, it will differ from the true value in a few least-significant bits. Accuracy depends on the timing interval - the more, the better. If the timing interval is insufficient, the result is -1. Also, see the comment on cpu_clock_measure for additional issues and pitfalls in using RDTSC for CPU frequency measurements. </dd></dl>

</div>
</div>
<a id="gae14aec8ba2ccbda9ae385370a6bd5361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae14aec8ba2ccbda9ae385370a6bd5361">&#9670;&nbsp;</a></span>cpu_clock_by_os()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_clock_by_os </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock, as reported by the OS. </p>
<p>This function uses OS-specific functions to obtain the CPU clock. It may differ from the true clock for several reasons:<br  />
<br  />
</p>
<p>i) The CPU might be in some power saving state, while the OS reports its full-power frequency, or vice-versa.<br  />
 ii) In some cases you can raise or lower the CPU frequency with overclocking utilities and the OS will not notice.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU clock frequency in MHz. If the OS is not (yet) supported or lacks the necessary reporting machinery, the return value is -1 </dd></dl>

</div>
</div>
<a id="ga6ba20c7c72b6c943e0b3e664ede42b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ba20c7c72b6c943e0b3e664ede42b80">&#9670;&nbsp;</a></span>cpu_clock_measure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_clock_measure </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quad_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the CPU clock frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millis</td><td>- How much time to waste in the busy-wait cycle. In millisecs. Useful values 10 - 1000 </td></tr>
    <tr><td class="paramname">quad_check</td><td>- Do a more thorough measurement if nonzero (see the explanation).</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs a busy-wait cycle for the given time and calculates the CPU frequency by the difference of the TSC values. The accuracy of the calculation depends on the length of the busy-wait cycle: more is better, but 100ms should be enough for most purposes.</p>
<p>While this will calculate the CPU frequency correctly in most cases, there are several reasons why it might be incorrect:<br  />
</p>
<p>i) RDTSC doesn't guarantee it will run at the same clock as the CPU. Apparently there aren't CPUs at the moment, but still, there's no guarantee.<br  />
 ii) The CPU might be in a low-frequency power saving mode, and the CPU might be switched to higher frequency at any time. If this happens during the measurement, the result can be anywhere between the low and high frequencies. Also, if you're interested in the high frequency value only, this function might return the low one instead.<br  />
 iii) On SMP systems exhibiting TSC drift (see <a class="el" href="group__libcpuid.html#ga08fe7335dd44017d8a653b6e2dc8977e">cpu_rdtsc</a>)</p>
<p>the quad_check option will run four consecutive measurements and then return the average of the two most-consistent results. The total runtime of the function will still be &lsquo;millis&rsquo; - consider using a bit more time for the timing interval.</p>
<p>Finally, for benchmarking / CPU intensive applications, the best strategy is to use the <a class="el" href="group__libcpuid.html#ga236be57c231aa5433416bd60c887a14a" title="Store TSC and timing info.">cpu_tsc_mark()</a> / <a class="el" href="group__libcpuid.html#gae69abf89db76d95039dc9338c4c5a697" title="Calculate TSC and timing difference.">cpu_tsc_unmark()</a> / <a class="el" href="group__libcpuid.html#ga55d3419eeac6d46d957875f1c302ca44" title="Calculates the CPU clock.">cpu_clock_by_mark()</a> method. Begin by mark()-ing about one second after application startup (allowing the power-saving manager to kick in and rise the frequency during that time), then unmark() just before application finishing. The result will most acurately represent at what frequency your app was running.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU clock frequency in MHz (within some measurement error margin). If RDTSC is not supported, the result is -1. </dd></dl>

</div>
</div>
<a id="ga43b66c6c5b7cb18218fd39fee60a72d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b66c6c5b7cb18218fd39fee60a72d2">&#9670;&nbsp;</a></span>cpu_exec_cpuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_exec_cpuid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the CPUID instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eax</td><td>- the value of the EAX register when executing CPUID </td></tr>
    <tr><td class="paramname">regs</td><td>- the results will be stored here. regs[0] = EAX, regs[1] = EBX, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>CPUID will be executed with EAX set to the given value and EBX, ECX, EDX set to zero. </dd></dl>

</div>
</div>
<a id="ga8ca716b437d82b2cfc97bc9f5cd1254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca716b437d82b2cfc97bc9f5cd1254a">&#9670;&nbsp;</a></span>cpu_exec_cpuid_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_exec_cpuid_ext </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>regs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the CPUID instruction with the given input registers. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a bit more generic version of cpu_exec_cpuid - it allows you to control all the registers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>- Input/output. Prior to executing CPUID, EAX, EBX, ECX and EDX will be set to regs[0], regs[1], regs[2] and regs[3]. After CPUID, this array will contain the results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e55a2581749333e4cfe3aad291e3889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e55a2581749333e4cfe3aad291e3889">&#9670;&nbsp;</a></span>cpu_feature_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpu_feature_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libcpuid.html#ga4c0b398deee739a645387c7329a4c289">cpu_feature_t</a>&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the short textual representation of a CPU flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>- the feature, whose textual representation is wanted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constant string like "fpu", "tsc", "sse2", etc. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the names of the returned flags are compatible with those from /proc/cpuinfo in Linux, with the exception of &lsquo;tm_amd&rsquo; </dd></dl>

</div>
</div>
<a id="gaa0b5bcc626ff3dd0482553657f9d600e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b5bcc626ff3dd0482553657f9d600e">&#9670;&nbsp;</a></span>cpu_identify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_identify </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcpu__id__t.html">cpu_id_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>- Input - a pointer to the raw CPUID data, which is obtained either by cpuid_get_raw_data or cpuid_deserialize_raw_data. Can also be NULL, in which case the functions calls cpuid_get_raw_data itself. </td></tr>
    <tr><td class="paramname">data</td><td>- Output - the decoded CPU features/info is written here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function will not fail, even if some of the information cannot be obtained. Even when the CPU is new and thus unknown to libcpuid, some generic info, such as "AMD K9 family CPU" will be written to data.cpu_codename, and most other things, such as the CPU flags, cache sizes, etc. should be detected correctly anyway. However, the function CAN fail, if the CPU is completely alien to libcpuid. </dd>
<dd>
While <a class="el" href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e" title="Identifies the CPU.">cpu_identify()</a> and <a class="el" href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746" title="Obtains the raw CPUID data from the current CPU.">cpuid_get_raw_data()</a> are fast for most purposes, running them several thousand times per second can hamper performance significantly. Specifically, avoid writing "cpu feature
      checker" wrapping function, which calls cpu_identify and returns the value of some flag, if that function is going to be called frequently. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="gaf84c8636236dacb88fc06f987dcae766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf84c8636236dacb88fc06f987dcae766">&#9670;&nbsp;</a></span>cpu_msr_driver_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_msr_driver_close </td>
          <td>(</td>
          <td class="paramtype">struct msr_driver_t *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an open MSR driver. </p>
<p>This function unloads the MSR driver opened by cpu_msr_driver_open and frees any resources associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- a handle to the MSR reader driver, as created by cpu_msr_driver_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="gab99453e100b3b502ca15b8a79198828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99453e100b3b502ca15b8a79198828a">&#9670;&nbsp;</a></span>cpu_msr_driver_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct msr_driver_t* cpu_msr_driver_open </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts/opens a driver, needed to read MSRs (Model Specific Registers) </p>
<p>On systems that support it, this function will create a temporary system driver, that has privileges to execute the RDMSR instruction. After the driver is created, you can read MSRs by calling <a class="el" href="group__libcpuid.html#ga0eddf30c99a094aa9942265948a13007">cpu_rdmsr</a></p>
<dl class="section return"><dt>Returns</dt><dd>a handle to the driver on success, and NULL on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="ga238b88d0db89dc89d0d78fb27e06feb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga238b88d0db89dc89d0d78fb27e06feb3">&#9670;&nbsp;</a></span>cpu_msr_driver_open_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct msr_driver_t* cpu_msr_driver_open_core </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>core_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a">cpu_msr_driver_open</a>, but accept one parameter. </p>
<p>This function works on certain operating systems (GNU/Linux, FreeBSD)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core_num</td><td>specify the core number for MSR. The first core number is 0. The last core number is <a class="el" href="group__libcpuid.html#ga1951ec0d29f43037df5e2e14cbae44b3">cpuid_get_total_cpus</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the driver on success, and NULL on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="gac977cbb78e00058098778411d7f784cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac977cbb78e00058098778411d7f784cf">&#9670;&nbsp;</a></span>cpu_msrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_msrinfo </td>
          <td>(</td>
          <td class="paramtype">struct msr_driver_t *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libcpuid.html#ga0e38033529430a12f20089b382d603a6">cpu_msrinfo_request_t</a>&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads extended CPU information from Model-Specific Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- a handle to an open MSR driver, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a" title="Starts/opens a driver, needed to read MSRs (Model Specific Registers)">cpu_msr_driver_open</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>- which info field should be returned. A list of available information entities is listed in the cpu_msrinfo_request_t enum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>if the requested information is available for the current processor model, the respective value is returned. if no information is available, or the CPU doesn't support the query, the special value CPU_INVALID_VALUE is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not MT-safe. If you intend to call it from multiple threads, guard it through a mutex or a similar primitive. </dd></dl>

</div>
</div>
<a id="ga0eddf30c99a094aa9942265948a13007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eddf30c99a094aa9942265948a13007">&#9670;&nbsp;</a></span>cpu_rdmsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_rdmsr </td>
          <td>(</td>
          <td class="paramtype">struct msr_driver_t *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>msr_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a Model-Specific Register (MSR) </p>
<p>If the CPU has MSRs (as indicated by the CPU_FEATURE_MSR flag), you can read a MSR with the given index by calling this function.</p>
<p>There are several prerequisites you must do before reading MSRs: 1) You must ensure the CPU has RDMSR. Check the CPU_FEATURE_MSR flag in <a class="el" href="structcpu__id__t.html#afe7f0f779b5986f1a89f02aa53d842a8">cpu_id_t::flags</a> 2) You must ensure that the CPU implements the specific MSR you intend to read. 3) You must open a MSR-reader driver. RDMSR is a privileged instruction and needs ring-0 access in order to work. This temporary driver is created by calling <a class="el" href="group__libcpuid.html#gab99453e100b3b502ca15b8a79198828a">cpu_msr_driver_open</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- a handle to the MSR reader driver, as created by cpu_msr_driver_open </td></tr>
    <tr><td class="paramname">msr_index</td><td>- the numeric ID of the MSR you want to read </td></tr>
    <tr><td class="paramname">result</td><td>- a pointer to a 64-bit integer, where the MSR value is stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="gae2056d06fd9ea3338535157e40ca6359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2056d06fd9ea3338535157e40ca6359">&#9670;&nbsp;</a></span>cpu_rdmsr_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpu_rdmsr_range </td>
          <td>(</td>
          <td class="paramtype">struct msr_driver_t *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>msr_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>highbit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lowbit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__libcpuid.html#ga0eddf30c99a094aa9942265948a13007">cpu_rdmsr</a>, but extract a range of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- a handle to the MSR reader driver, as created by cpu_msr_driver_open </td></tr>
    <tr><td class="paramname">msr_index</td><td>- the numeric ID of the MSR you want to read </td></tr>
    <tr><td class="paramname">highbit</td><td>- the high bit in range, must be inferior to 64 </td></tr>
    <tr><td class="paramname">lowbit</td><td>- the low bit in range, must be equal or superior to 0 </td></tr>
    <tr><td class="paramname">result</td><td>- a pointer to a 64-bit integer, where the MSR value is stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="ga08fe7335dd44017d8a653b6e2dc8977e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08fe7335dd44017d8a653b6e2dc8977e">&#9670;&nbsp;</a></span>cpu_rdtsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_rdtsc </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes RDTSC. </p>
<p>The RDTSC (ReaD Time Stamp Counter) instruction gives access to an internal 64-bit counter, which usually increments at each clock cycle. This can be used for various timing routines, and as a very precise clock source. It is set to zero on system startup. Beware that may not increment at the same frequency as the CPU. Consecutive calls of RDTSC are, however, guaranteed to return monotonically-increasing values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>- a pointer to a 64-bit unsigned integer, where the TSC value will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If 100% compatibility is a concern, you must first check if the RDTSC instruction is present (if it is not, your program will crash with "invalid opcode" exception). Only some very old processors (i486, early AMD K5 and some Cyrix CPUs) lack that instruction - they should have become exceedingly rare these days. To verify RDTSC presence, run <a class="el" href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e" title="Identifies the CPU.">cpu_identify()</a> and check flags[CPU_FEATURE_TSC].</dd>
<dd>
The monotonically increasing nature of the TSC may be violated on SMP systems, if their TSC clocks run at different rate. If the OS doesn't account for that, the TSC drift may become arbitrary large. </dd></dl>

</div>
</div>
<a id="ga236be57c231aa5433416bd60c887a14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga236be57c231aa5433416bd60c887a14a">&#9670;&nbsp;</a></span>cpu_tsc_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_tsc_mark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store TSC and timing info. </p>
<p>This function stores the current TSC value and current time info from a precise OS-specific clock source in the <a class="el" href="structcpu__mark__t.html" title="Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.">cpu_mark_t</a> structure. The sys_clock field contains time with microsecond resolution. The values can later be used to measure time intervals, number of clocks, FPU frequency, etc. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#ga08fe7335dd44017d8a653b6e2dc8977e" title="Executes RDTSC.">cpu_rdtsc</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>[out] - a pointer to a <a class="el" href="structcpu__mark__t.html" title="Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.">cpu_mark_t</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae69abf89db76d95039dc9338c4c5a697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69abf89db76d95039dc9338c4c5a697">&#9670;&nbsp;</a></span>cpu_tsc_unmark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpu_tsc_unmark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__mark__t.html">cpu_mark_t</a> *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate TSC and timing difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>- input/output: a pointer to a <a class="el" href="structcpu__mark__t.html" title="Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.">cpu_mark_t</a> structure, which has already been initialized by cpu_tsc_mark. The difference in TSC and time will be written here.</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the TSC and time difference, by obtaining the current TSC and timing values and subtracting the contents of the &lsquo;mark&rsquo; structure from them. Results are written in the same structure.</p>
<p>Example: </p><div class="fragment"><div class="line">...</div>
<div class="line">struct <a class="code" href="structcpu__mark__t.html">cpu_mark_t</a> mark;</div>
<div class="line"><a class="code" href="group__libcpuid.html#ga236be57c231aa5433416bd60c887a14a">cpu_tsc_mark</a>(&amp;mark);</div>
<div class="line">foo();</div>
<div class="line"><a class="code" href="group__libcpuid.html#gae69abf89db76d95039dc9338c4c5a697">cpu_tsc_unmark</a>(&amp;mark);</div>
<div class="line">printf(<span class="stringliteral">&quot;Foo finished. Executed in %llu cycles and %llu usecs\n&quot;</span>,</div>
<div class="line">       mark.<a class="code" href="structcpu__mark__t.html#af536cc43f52784351699cccd1325e00e">tsc</a>, mark.<a class="code" href="structcpu__mark__t.html#a9b8ec61059a41a7c91d9b841d85ccf1b">sys_clock</a>);</div>
<div class="line">...</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad6c337c82f669c5c158f25716c080f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c337c82f669c5c158f25716c080f6c">&#9670;&nbsp;</a></span>cpuid_deserialize_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpuid_deserialize_raw_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads raw CPUID data from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a pointer to <a class="el" href="structcpu__raw__data__t.html" title="Contains just the raw CPUID data.">cpu_raw_data_t</a> structure. The deserialized data will be written here. </td></tr>
    <tr><td class="paramname">filename</td><td>- the path of the file, containing the serialized raw data. If empty, stdin will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may fail, if the file is created by different version of the library. Also, see the notes on cpuid_serialize_raw_data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="gaa9e877c240b70b78f0781aad37f4c169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e877c240b70b78f0781aad37f4c169">&#9670;&nbsp;</a></span>cpuid_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpuid_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns textual description of the last error. </p>
<p>libcpuid stores an &lsquo;errno&rsquo;-style error status, whose description can be obtained with this function. </p><dl class="section note"><dt>Note</dt><dd>This function is not thread-safe </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="ga7fe37f4d3025587d30ec82287ebfe236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe37f4d3025587d30ec82287ebfe236">&#9670;&nbsp;</a></span>cpuid_free_cpu_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpuid_free_cpu_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__list__t.html">cpu_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a CPU list. </p>
<p>This function deletes all the memory associated with a CPU list, as obtained by <a class="el" href="group__libcpuid.html#ga1b0131f6d12aca2d002175abcd9a1d20" title="Gets a list of all known CPU names from a specific vendor.">cpuid_get_cpu_list()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>- the list to be free()'d. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b0131f6d12aca2d002175abcd9a1d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0131f6d12aca2d002175abcd9a1d20">&#9670;&nbsp;</a></span>cpuid_get_cpu_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpuid_get_cpu_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a>&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcpu__list__t.html">cpu_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of all known CPU names from a specific vendor. </p>
<p>This function compiles a list of all known CPU (code)names (i.e. the possible values of <a class="el" href="structcpu__id__t.html#adec5c2819d5ab82676a39f6cae26d89c">cpu_id_t::cpu_codename</a>) for the given vendor.</p>
<p>There are about 100 entries for Intel and AMD, and a few for the other vendors. The list is written out in approximate chronological introduction order of the parts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vendor</td><td>the vendor to be queried </td></tr>
    <tr><td class="paramname">list</td><td>[out] the resulting list will be written here. NOTE: As the memory is dynamically allocated, be sure to call <a class="el" href="group__libcpuid.html#ga7fe37f4d3025587d30ec82287ebfe236" title="Frees a CPU list.">cpuid_free_cpu_list()</a> after you're done with the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcpu__list__t.html" title="a structure that holds a list of processor names">cpu_list_t</a> </dd></dl>

</div>
</div>
<a id="gad973835515aa3b0d807b07279f03b965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad973835515aa3b0d807b07279f03b965">&#9670;&nbsp;</a></span>cpuid_get_epc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcpu__epc__t.html">cpu_epc_t</a> cpuid_get_epc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches information about an EPC (Enclave Page Cache) area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- zero-based index, valid range [0..cpu_id_t.egx.num_epc_sections) </td></tr>
    <tr><td class="paramname">raw</td><td>- a pointer to fetched raw CPUID data. Needed only for testing, you can safely pass NULL here (if you pass a real structure, it will be used for fetching the leaf 12h data if index &lt; 2; otherwise the real CPUID instruction will be used). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested data. If the CPU doesn't support SGX, or if index &gt;= cpu_id_t.egx.num_epc_sections, both fields of the returned structure will be zeros. </dd></dl>

</div>
</div>
<a id="gacfc107ea367e6b918ca17fdf2c492746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfc107ea367e6b918ca17fdf2c492746">&#9670;&nbsp;</a></span>cpuid_get_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpuid_get_raw_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the raw CPUID data from the current CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a pointer to <a class="el" href="structcpu__raw__data__t.html" title="Contains just the raw CPUID data.">cpu_raw_data_t</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="ga1951ec0d29f43037df5e2e14cbae44b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1951ec0d29f43037df5e2e14cbae44b3">&#9670;&nbsp;</a></span>cpuid_get_total_cpus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpuid_get_total_cpus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of logical CPU threads (even if CPUID is not present). </p>
<p>Under VM, this number (and total_logical_cpus, since they are fetched with the same code) may be nonsensical, i.e. might not equal NumPhysicalCPUs*NumCoresPerCPU*HyperThreading. This is because no matter how many logical threads the host machine has, you may limit them in the VM to any number you like. <b>This</b> is the number returned by <a class="el" href="group__libcpuid.html#ga1951ec0d29f43037df5e2e14cbae44b3" title="Returns the total number of logical CPU threads (even if CPUID is not present).">cpuid_get_total_cpus()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of logical CPU threads available. Equals the <a class="el" href="structcpu__id__t.html#ae7ad9a6544e5fd9b5610824d1c66896e">cpu_id_t::total_logical_cpus</a>. </dd></dl>

</div>
</div>
<a id="ga71b269fd7a481e1204bdc2bc0277cc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b269fd7a481e1204bdc2bc0277cc47">&#9670;&nbsp;</a></span>cpuid_get_vendor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28">cpu_vendor_t</a> cpuid_get_vendor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the CPU vendor from CPUID from the current CPU. </p>
<dl class="section note"><dt>Note</dt><dd>The result is cached. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>VENDOR_UNKNOWN if failed, otherwise the CPU vendor type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaee3591049f485bb93dbd26dd91684d28" title="CPU vendor, as guessed from the Vendor String.">cpu_vendor_t</a> </dd></dl>

</div>
</div>
<a id="ga0517d3660baee30704cc3a28b0b69d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0517d3660baee30704cc3a28b0b69d10">&#9670;&nbsp;</a></span>cpuid_lib_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpuid_lib_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the libcpuid version. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation of the libcpuid version, like "0.1.1" </dd></dl>

</div>
</div>
<a id="ga2b686ad8bf6d231de8d8383090022b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b686ad8bf6d231de8d8383090022b4f">&#9670;&nbsp;</a></span>cpuid_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpuid_present </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the CPUID instruction is supported. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if CPUID is present </td></tr>
    <tr><td class="paramname">0</td><td>the CPU doesn't have CPUID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga454db9d6dcf13250280cf9b64314235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454db9d6dcf13250280cf9b64314235e">&#9670;&nbsp;</a></span>cpuid_serialize_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpuid_serialize_raw_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcpu__raw__data__t.html">cpu_raw_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the raw CPUID data to a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a pointer to <a class="el" href="structcpu__raw__data__t.html" title="Contains just the raw CPUID data.">cpu_raw_data_t</a> structure </td></tr>
    <tr><td class="paramname">filename</td><td>- the path of the file, where the serialized data should be written. If empty, stdout will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is intended primarily for debugging. On some processor, which is not currently supported or not completely recognized by cpu_identify, one can still successfully get the raw data and write it to a file. libcpuid developers can later import this file and debug the detection code as if running on the actual hardware. The file is simple text format of "something=value" pairs. Version info is also written, but the format is not intended to be neither backward- nor forward compatible. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
<a id="ga97fe8a0702c19a1826cbfe8f69e5e264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97fe8a0702c19a1826cbfe8f69e5e264">&#9670;&nbsp;</a></span>cpuid_set_verbosiness_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpuid_set_verbosiness_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosiness level. </p>
<p>When the verbosiness level is above zero, some functions might print diagnostic information about what are they doing. The higher the level is, the more detail is printed. Level zero is guaranteed to omit all such output. The output is written using the same machinery as the warnings, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaa403016f62608ba42d910f7e560c2f2a" title="Sets the warning print function.">cpuid_set_warn_function()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the desired verbosiness level. Useful values 0..2 inclusive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa403016f62608ba42d910f7e560c2f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa403016f62608ba42d910f7e560c2f2a">&#9670;&nbsp;</a></span>cpuid_set_warn_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libcpuid_warn_fn_t cpuid_set_warn_function </td>
          <td>(</td>
          <td class="paramtype">libcpuid_warn_fn_t&#160;</td>
          <td class="paramname"><em>warn_fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the warning print function. </p>
<p>In some cases, the internal libcpuid machinery would like to emit useful debug warnings. By default, these warnings are written to stderr. However, you can set a custom function that will receive those warnings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warn_fun</td><td>- the warning function you want to set. If NULL, warnings are disabled. The function takes const char* argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current warning function. You can use the return value to keep the previous warning function and restore it at your discretion. </dd></dl>

</div>
</div>
<a id="gaa7b1d6fc07f6019f0912057a2320c3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7b1d6fc07f6019f0912057a2320c3e6">&#9670;&nbsp;</a></span>msr_serialize_raw_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msr_serialize_raw_data </td>
          <td>(</td>
          <td class="paramtype">struct msr_driver_t *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the raw MSR data to a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- a handle to the MSR reader driver, as created by cpu_msr_driver_open </td></tr>
    <tr><td class="paramname">filename</td><td>- the path of the file, where the serialized data should be written. If empty, stdout will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is intended primarily for debugging. On some processor, which is not currently supported or not completely recognized by cpu_identify, one can still successfully get the raw data and write it to a file. libcpuid developers can later import this file and debug the detection code as if running on the actual hardware. The file is simple text format of "something=value" pairs. Version info is also written, but the format is not intended to be neither backward- nor forward compatible. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero if successful, and some negative number on error. The error message can be obtained by calling <a class="el" href="group__libcpuid.html#gaa9e877c240b70b78f0781aad37f4c169">cpuid_error</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libcpuid.html#gaaaad3aee57ed8705424f5884fb15849f" title="Describes common library error codes.">cpu_error_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="astructcpu__sgx__t_html_a4e61408256b02bf7b7a11f8a138c4d64"><div class="ttname"><a href="structcpu__sgx__t.html#a4e61408256b02bf7b7a11f8a138c4d64">cpu_sgx_t::flags</a></div><div class="ttdeci">uint8_t flags[SGX_FLAGS_MAX]</div><div class="ttdef"><b>Definition:</b> libcpuid.h:197</div></div>
<div class="ttc" id="agroup__libcpuid_html_ga236be57c231aa5433416bd60c887a14a"><div class="ttname"><a href="group__libcpuid.html#ga236be57c231aa5433416bd60c887a14a">cpu_tsc_mark</a></div><div class="ttdeci">void cpu_tsc_mark(struct cpu_mark_t *mark)</div><div class="ttdoc">Store TSC and timing info.</div></div>
<div class="ttc" id="agroup__libcpuid_html_gacfc107ea367e6b918ca17fdf2c492746"><div class="ttname"><a href="group__libcpuid.html#gacfc107ea367e6b918ca17fdf2c492746">cpuid_get_raw_data</a></div><div class="ttdeci">int cpuid_get_raw_data(struct cpu_raw_data_t *data)</div><div class="ttdoc">Obtains the raw CPUID data from the current CPU.</div></div>
<div class="ttc" id="agroup__libcpuid_html_gaa0b5bcc626ff3dd0482553657f9d600e"><div class="ttname"><a href="group__libcpuid.html#gaa0b5bcc626ff3dd0482553657f9d600e">cpu_identify</a></div><div class="ttdeci">int cpu_identify(struct cpu_raw_data_t *raw, struct cpu_id_t *data)</div><div class="ttdoc">Identifies the CPU.</div></div>
<div class="ttc" id="astructcpu__sgx__t_html_a9e44e3fb6976c51439d5acb01024e8c2"><div class="ttname"><a href="structcpu__sgx__t.html#a9e44e3fb6976c51439d5acb01024e8c2">cpu_sgx_t::present</a></div><div class="ttdeci">uint32_t present</div><div class="ttdef"><b>Definition:</b> libcpuid.h:181</div></div>
<div class="ttc" id="astructcpu__mark__t_html"><div class="ttname"><a href="structcpu__mark__t.html">cpu_mark_t</a></div><div class="ttdoc">Internal structure, used in cpu_tsc_mark, cpu_tsc_unmark and cpu_clock_by_mark.</div><div class="ttdef"><b>Definition:</b> libcpuid.h:565</div></div>
<div class="ttc" id="agroup__libcpuid_html_gae69abf89db76d95039dc9338c4c5a697"><div class="ttname"><a href="group__libcpuid.html#gae69abf89db76d95039dc9338c4c5a697">cpu_tsc_unmark</a></div><div class="ttdeci">void cpu_tsc_unmark(struct cpu_mark_t *mark)</div><div class="ttdoc">Calculate TSC and timing difference.</div></div>
<div class="ttc" id="agroup__libcpuid_html_ggab7731d6f7447310c9a29d2c92c867d4fa09de49d5e0772b8ee6e232f9aeefcf25"><div class="ttname"><a href="group__libcpuid.html#ggab7731d6f7447310c9a29d2c92c867d4fa09de49d5e0772b8ee6e232f9aeefcf25">INTEL_SGX1</a></div><div class="ttdeci">@ INTEL_SGX1</div><div class="ttdef"><b>Definition:</b> libcpuid.h:531</div></div>
<div class="ttc" id="astructcpu__mark__t_html_a9b8ec61059a41a7c91d9b841d85ccf1b"><div class="ttname"><a href="structcpu__mark__t.html#a9b8ec61059a41a7c91d9b841d85ccf1b">cpu_mark_t::sys_clock</a></div><div class="ttdeci">uint64_t sys_clock</div><div class="ttdef"><b>Definition:</b> libcpuid.h:567</div></div>
<div class="ttc" id="agroup__libcpuid_html_gga4c0b398deee739a645387c7329a4c289a4256f8c13070e3b8bd6be3010a5c1226"><div class="ttname"><a href="group__libcpuid.html#gga4c0b398deee739a645387c7329a4c289a4256f8c13070e3b8bd6be3010a5c1226">CPU_FEATURE_SSE2</a></div><div class="ttdeci">@ CPU_FEATURE_SSE2</div><div class="ttdef"><b>Definition:</b> libcpuid.h:406</div></div>
<div class="ttc" id="astructcpu__id__t_html_afe7f0f779b5986f1a89f02aa53d842a8"><div class="ttname"><a href="structcpu__id__t.html#afe7f0f779b5986f1a89f02aa53d842a8">cpu_id_t::flags</a></div><div class="ttdeci">uint8_t flags[CPU_FLAGS_MAX]</div><div class="ttdef"><b>Definition:</b> libcpuid.h:238</div></div>
<div class="ttc" id="astructcpu__raw__data__t_html"><div class="ttname"><a href="structcpu__raw__data__t.html">cpu_raw_data_t</a></div><div class="ttdoc">Contains just the raw CPUID data.</div><div class="ttdef"><b>Definition:</b> libcpuid.h:127</div></div>
<div class="ttc" id="astructcpu__id__t_html_a89b162728b0d5dbaf7b3169b2096ecbc"><div class="ttname"><a href="structcpu__id__t.html#a89b162728b0d5dbaf7b3169b2096ecbc">cpu_id_t::sgx</a></div><div class="ttdeci">struct cpu_sgx_t sgx</div><div class="ttdef"><b>Definition:</b> libcpuid.h:358</div></div>
<div class="ttc" id="astructcpu__id__t_html"><div class="ttname"><a href="structcpu__id__t.html">cpu_id_t</a></div><div class="ttdoc">This contains the recognized CPU features/info.</div><div class="ttdef"><b>Definition:</b> libcpuid.h:223</div></div>
<div class="ttc" id="astructcpu__mark__t_html_af536cc43f52784351699cccd1325e00e"><div class="ttname"><a href="structcpu__mark__t.html#af536cc43f52784351699cccd1325e00e">cpu_mark_t::tsc</a></div><div class="ttdeci">uint64_t tsc</div><div class="ttdef"><b>Definition:</b> libcpuid.h:566</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
